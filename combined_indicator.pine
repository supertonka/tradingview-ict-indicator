//@version=6
indicator(title="EMA + M&W Pattern + OrderBlock", shorttitle="EMA+M&W+OB", overlay=true)

// ==================
// EMA Indicator Settings
// ==================
EMA_GRP = "EMA Settings"
len = input.int(9, minval=1, title="Length", group=EMA_GRP)
src = input(close, title="Source", group=EMA_GRP)
offset = input.int(title="Offset", defval=0, minval=-500, maxval=500, display = display.data_window, group=EMA_GRP)
out = ta.ema(src, len)
plot(out, title="EMA", color=color.blue, offset=offset)

// Smoothing MA inputs
SMOOTH_GRP = "EMA Smoothing Settings"
TT_BB = "Only applies when 'SMA + Bollinger Bands' is selected. Determines the distance between the SMA and the bands."
maTypeInput = input.string("None", "Type", options = ["None", "SMA", "SMA + Bollinger Bands", "EMA", "SMMA (RMA)", "WMA", "VWMA"], group = SMOOTH_GRP, display = display.data_window)
maLengthInput = input.int(14, "Length", group = SMOOTH_GRP, display = display.data_window)
bbMultInput = input.float(2.0, "BB StdDev", minval = 0.001, maxval = 50, step = 0.5, tooltip = TT_BB, group = SMOOTH_GRP, display = display.data_window)
var enableMA = maTypeInput != "None"
var isBB = maTypeInput == "SMA + Bollinger Bands"

// Smoothing MA Calculation
ma(source, length, MAtype) =>
	switch MAtype
		"SMA"                   => ta.sma(source, length)
		"SMA + Bollinger Bands" => ta.sma(source, length)
		"EMA"                   => ta.ema(source, length)
		"SMMA (RMA)"            => ta.rma(source, length)
		"WMA"                   => ta.wma(source, length)
		"VWMA"                  => ta.vwma(source, length)

// Smoothing MA plots
smoothingMA = enableMA ? ma(out, maLengthInput, maTypeInput) : na
smoothingStDev = isBB ? ta.stdev(out, maLengthInput) * bbMultInput : na
plot(smoothingMA, "EMA-based MA", color=color.yellow, display = enableMA ? display.all : display.none, editable = enableMA)
bbUpperBand = plot(smoothingMA + smoothingStDev, title = "Upper Bollinger Band", color=color.green, display = isBB ? display.all : display.none, editable = isBB)
bbLowerBand = plot(smoothingMA - smoothingStDev, title = "Lower Bollinger Band", color=color.green, display = isBB ? display.all : display.none, editable = isBB)
fill(bbUpperBand, bbLowerBand, color= isBB ? color.new(color.green, 90) : na, title="Bollinger Bands Background Fill", display = isBB ? display.all : display.none, editable = isBB) 

// ==================
// OrderBlock Settings
// ==================
OB_GRP = "OrderBlock Settings"
obLength = input.int(5, 'Volume Pivot Length', minval = 1, group=OB_GRP)
bullExtLast = input.int(3, 'Bullish OB ', minval = 1, inline = 'bull', group=OB_GRP)
bgBullCss = input.color(color.new(#169400, 80), '', inline = 'bull', group=OB_GRP)
bullCss = input.color(#169400, '', inline = 'bull', group=OB_GRP)
bullAvgCss = input.color(color.new(#9598a1, 37), '', inline = 'bull', group=OB_GRP)
bearExtLast = input.int(3, 'Bearish OB', minval = 1, inline = 'bear', group=OB_GRP)
bgBearCss = input.color(color.new(#ff1100, 80), '', inline = 'bear', group=OB_GRP)
bearCss = input.color(#ff1100, '', inline = 'bear', group=OB_GRP)
bearAvgCss = input.color(color.new(#9598a1, 37), '', inline = 'bear', group=OB_GRP)

get_line_style(style) =>
    out = switch style
        '⎯⎯⎯'  => line.style_solid
        '----' => line.style_dashed
        '····' => line.style_dotted

get_coordinates(condition, top, btm, ob_val)=>
    var ob_top  = array.new_float(0)
    var ob_btm  = array.new_float(0)
    var ob_avg  = array.new_float(0)
    var ob_left = array.new_int(0)

    float ob = na

    if condition
        avg = math.avg(top, btm)
        
        array.unshift(ob_top, top)
        array.unshift(ob_btm, btm)
        array.unshift(ob_avg, avg)
        array.unshift(ob_left, time[obLength])
        
        ob := ob_val
    
    [ob_top, ob_btm, ob_avg, ob_left, ob]

remove_mitigated(ob_top, ob_btm, ob_left, ob_avg, target, bull)=>
    mitigated = false
    target_array = bull ? ob_btm : ob_top

    for element in target_array
        idx = array.indexof(target_array, element)

        if (bull ? target < element : target > element)
            mitigated := true

            array.remove(ob_top, idx)
            array.remove(ob_btm, idx)
            array.remove(ob_avg, idx)
            array.remove(ob_left, idx)
    
    mitigated

set_order_blocks(ob_top, ob_btm, ob_left, ob_avg, ext_last, bg_css, border_css, lvl_css)=>
    var ob_box = array.new_box(0)
    var ob_lvl = array.new_line(0)

    if barstate.isfirst
        for i = 0 to ext_last-1
            array.unshift(ob_box, box.new(na,na,na,na
              , xloc = xloc.bar_time
              , extend= extend.right
              , bgcolor = bg_css
              , border_color = color.new(border_css, 70)))

            array.unshift(ob_lvl, line.new(na,na,na,na
              , xloc = xloc.bar_time
              , extend = extend.right
              , color = lvl_css
              , style = get_line_style('⎯⎯⎯')
              , width = 1))

    if barstate.islast
        if array.size(ob_top) > 0
            for i = 0 to math.min(ext_last-1, array.size(ob_top)-1)
                get_box = array.get(ob_box, i)
                get_lvl = array.get(ob_lvl, i)

                box.set_lefttop(get_box, array.get(ob_left, i), array.get(ob_top, i))
                box.set_rightbottom(get_box, array.get(ob_left, i), array.get(ob_btm, i))

                line.set_xy1(get_lvl, array.get(ob_left, i), array.get(ob_avg, i))
                line.set_xy2(get_lvl, array.get(ob_left, i)+1, array.get(ob_avg, i))

var os = 0
var target_bull = 0.
var target_bear = 0.

upper = ta.highest(obLength)
lower = ta.lowest(obLength)

target_bull := ta.lowest(close, obLength)
target_bear := ta.highest(close, obLength)

os := high[obLength] > upper ? 0 : low[obLength] < lower ? 1 : os[1]

phv = ta.pivothigh(volume, obLength, obLength)

[bull_top, bull_btm, bull_avg, bull_left, bull_ob] = get_coordinates(not na(phv) and os == 1, hl2[obLength], low[obLength], low[obLength])
[bear_top, bear_btm, bear_avg, bear_left, bear_ob] = get_coordinates(not na(phv) and os == 0, high[obLength], hl2[obLength], high[obLength])

mitigated_bull = remove_mitigated(bull_top, bull_btm, bull_left, bull_avg, target_bull, true)
mitigated_bear = remove_mitigated(bear_top, bear_btm, bear_left, bear_avg, target_bear, false)

set_order_blocks(bull_top, bull_btm, bull_left, bull_avg, bullExtLast, bgBullCss, bullCss, bullAvgCss)
set_order_blocks(bear_top, bear_btm, bear_left, bear_avg, bearExtLast, bgBearCss, bearCss, bearAvgCss)

alertcondition(not na(bull_ob), "Bullish OB Detected", "Bullish OrderBlock formed")
alertcondition(not na(bear_ob), "Bearish OB Detected", "Bearish OrderBlock formed")

// ==================
// M&W Pattern Settings
// ==================
MW_GRP = "M&W Pattern Settings"
x = input.int(21, "Time Horizon", tooltip = "Controls the look-back and time horizon of the patterns, a larger value will detect longer term patterns", group=MW_GRP)
sig = input.bool(false, "Show Signal Labels Only", tooltip = "When enabled, only the labels showing the second pivot of the double top/bottom will show", group=MW_GRP)

MW_COLORS = "M&W Pattern Colors"
green = input.color(#00ffbb, "Bullish Color", group = MW_COLORS, tooltip="Color for bullish trend")
red = input.color(#ff1100, "Bearish Color", group = MW_COLORS, tooltip="Color for bearish trend")

type store
    int   dir
    int   n
    float y

limit = ta.sma(math.abs(open-close), 100)

ph = ta.pivothigh(close, x,x)
pl = ta.pivotlow(close, x,x)

var pph = float(na)
var ppl = float(na)
var cpph = float(na)
var cppl = float(na)
var ln = int(na)
var hn = int(na)
var lpt = 0
var awaiting_DBC = 0
var awaiting_DTC = 0

potential = false
var store[] sequence = array.new<store>()
var t = array.new_line()
var t1 = array.new_line()
var tthresh = 0.0
var bthresh = 0.0

if not na(ph)
    lpt := 1
    if awaiting_DBC == 1
        awaiting_DBC := 0
        if not sig
            label.new(bar_index, bthresh, style = label.style_diamond, size = size.tiny, color = color.orange)
    if awaiting_DTC == 1
        awaiting_DTC := 0
        if not sig
            label.new(bar_index, tthresh, style = label.style_diamond, size = size.tiny, color = color.orange)
    if na(ppl)
        hn := bar_index-x
        cpph := ph
        sequence.unshift(store.new(1, hn, close[bar_index-hn]))
        pph := ph
        
    else if ph > ppl and (lpt == lpt[1] ? ph > pph : true)
        hn := bar_index-x
        cppl := ppl
        sequence.unshift(store.new(-1, ln, close[bar_index-ln]))
        pph := ph
        

if not na(pl)
    lpt := -1
    if awaiting_DBC == 1
        awaiting_DBC := 0
        if not sig
            label.new(bar_index, bthresh, style = label.style_diamond, size = size.tiny, color = color.orange)
    if awaiting_DTC == 1
        awaiting_DTC := 0
        if not sig
            label.new(bar_index, tthresh, style = label.style_diamond, size = size.tiny, color = color.orange)
    if na(pph)
        ln := bar_index-x
        cppl := pl
        sequence.unshift(store.new(-1, ln, close[bar_index-ln]))
        ppl := pl
        
    else if pl < pph and (lpt == lpt[1] ? pl < ppl : true)
        ln := bar_index-x
        cpph := pph
        sequence.unshift(store.new(1, hn, close[bar_index-hn]))
        ppl := pl

while sequence.size() > 3
    sequence.pop()

if sequence.size() > 2
    if not na(ph) and sequence.first().dir == -1 and sequence.get(1).dir == 1 and math.abs(close[x] - sequence.get(1).y) < limit and lpt[1] != 1
        trigger = sequence.get(0).y
        label.new(bar_index-x, close[x], style = label.style_label_down, size = size.large, color = red)
        if not sig
            t1.unshift(line.new(sequence.get(0).n, sequence.get(0).y, sequence.get(0).n + 1, sequence.get(0).y, xloc = xloc.bar_index, color = red, width = 2, style = line.style_dashed))
        awaiting_DTC := 1
        tthresh := sequence.get(0).y
        if not sig
            l0 = line.new(sequence.get(1).n, sequence.get(1).y, sequence.get(2).n, sequence.get(2).y, xloc = xloc.bar_index, color = red, width = 2)
            l1 = line.new(sequence.get(1).n, sequence.get(1).y, sequence.get(0).n, sequence.get(0).y, xloc = xloc.bar_index, color = red, width = 2)
            l2 = line.new(sequence.get(0).n, sequence.get(0).y, bar_index-x, ph, xloc = xloc.bar_index, color = red, width = 2)
            linefill.new(l0, l1, color.new(red, 70))
            linefill.new(t1.first(), l2, color.new(red, 70))

    if not na(pl) and sequence.first().dir == 1 and sequence.get(1).dir == -1 and math.abs(close[x] - sequence.get(1).y) < limit and lpt[1] != -1
        trigger = sequence.get(0).y
        label.new(bar_index-x, close[x], style = label.style_label_up, size = size.large, color = green)
        if not sig
            t.unshift(line.new(sequence.get(0).n, sequence.get(0).y, sequence.get(0).n + 1, sequence.get(0).y, xloc = xloc.bar_index, color = green, width = 2, style = line.style_dashed))
        awaiting_DBC := 1
        bthresh := sequence.get(0).y
        if not sig
            l0 = line.new(sequence.get(1).n, sequence.get(1).y, sequence.get(2).n, sequence.get(2).y, xloc = xloc.bar_index, color = green, width = 2)
            l1 = line.new(sequence.get(1).n, sequence.get(1).y, sequence.get(0).n, sequence.get(0).y, xloc = xloc.bar_index, color = green, width = 2)
            l2 = line.new(sequence.get(0).n, sequence.get(0).y, bar_index-x, pl, xloc = xloc.bar_index, color = green, width = 2)
            linefill.new(l0, l1, color.new(green, 70))
            linefill.new(t.first(), l2, color.new(green, 70))

DTC = 0
DBC = 0

if awaiting_DTC == 1
    if close < tthresh
        awaiting_DTC := 0
        tthresh := 0
        if not sig
            t1.first().set_x2(bar_index)
        DTC := 1

if awaiting_DBC == 1
    if close > bthresh
        awaiting_DBC := 0
        awaiting_DBC := 0
        if not sig
            t.first().set_x2(bar_index)
        DBC := 1

if t.size() > 0
    qt = t.size()

    for i = qt - 1 to 0
        if i < t.size()
            cL = t.get(i)
            yL = cL.get_x1()
            vert = cL.get_y1()

            if awaiting_DBC == 1
                cL.set_x2(bar_index + 1)

            else
                t.pop()

if t1.size() > 0
    qt = t.size()

    for i = qt - 1 to 0
        if i < t1.size()
            cL = t1.get(i)
            yL = cL.get_x1()
            vert = cL.get_y1()

            if awaiting_DTC == 1
                cL.set_x2(bar_index + 1)

            else
                t1.pop()

alertcondition(not na(pl) and sequence.first().dir == 1 and sequence.get(1).dir == -1 and math.abs(close[x] - sequence.get(1).y) < limit and lpt[1] != -1, "Potential Double Bottom")
alertcondition(not na(ph) and sequence.first().dir == -1 and sequence.get(1).dir == 1 and math.abs(close[x] - sequence.get(1).y) < limit and lpt[1] != 1, "Potential Double Top")
alertcondition(DBC == 1, "Double Bottom Confirmed")
alertcondition(DTC == 1, "Double Top Confirmed")
