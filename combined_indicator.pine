//@version=6
indicator(title="EMA + M&W Pattern + OrderBlock", shorttitle="EMA+M&W+OB", overlay=true)

// ==================
// EMA Indicator Settings
// ==================
EMA_GRP = "EMA Settings"
len = input.int(9, minval=1, title="Length", group=EMA_GRP)
src = input(close, title="Source", group=EMA_GRP)
offset = input.int(title="Offset", defval=0, minval=-500, maxval=500, display = display.data_window, group=EMA_GRP)
out = ta.ema(src, len)
plot(out, title="EMA", color=color.blue, offset=offset)

// Smoothing MA inputs
SMOOTH_GRP = "EMA Smoothing Settings"
TT_BB = "Only applies when 'SMA + Bollinger Bands' is selected. Determines the distance between the SMA and the bands."
maTypeInput = input.string("None", "Type", options = ["None", "SMA", "SMA + Bollinger Bands", "EMA", "SMMA (RMA)", "WMA", "VWMA"], group = SMOOTH_GRP, display = display.data_window)
maLengthInput = input.int(14, "Length", group = SMOOTH_GRP, display = display.data_window)
bbMultInput = input.float(2.0, "BB StdDev", minval = 0.001, maxval = 50, step = 0.5, tooltip = TT_BB, group = SMOOTH_GRP, display = display.data_window)
var enableMA = maTypeInput != "None"
var isBB = maTypeInput == "SMA + Bollinger Bands"

// Smoothing MA Calculation
ma(source, length, MAtype) =>
	switch MAtype
		"SMA"                   => ta.sma(source, length)
		"SMA + Bollinger Bands" => ta.sma(source, length)
		"EMA"                   => ta.ema(source, length)
		"SMMA (RMA)"            => ta.rma(source, length)
		"WMA"                   => ta.wma(source, length)
		"VWMA"                  => ta.vwma(source, length)

// Smoothing MA plots
smoothingMA = enableMA ? ma(out, maLengthInput, maTypeInput) : na
smoothingStDev = isBB ? ta.stdev(out, maLengthInput) * bbMultInput : na
plot(smoothingMA, "EMA-based MA", color=color.yellow, display = enableMA ? display.all : display.none, editable = enableMA)
bbUpperBand = plot(smoothingMA + smoothingStDev, title = "Upper Bollinger Band", color=color.green, display = isBB ? display.all : display.none, editable = isBB)
bbLowerBand = plot(smoothingMA - smoothingStDev, title = "Lower Bollinger Band", color=color.green, display = isBB ? display.all : display.none, editable = isBB)
fill(bbUpperBand, bbLowerBand, color= isBB ? color.new(color.green, 90) : na, title="Bollinger Bands Background Fill", display = isBB ? display.all : display.none, editable = isBB) 

// ==================
// OrderBlock Settings
// ==================
OB_GRP = "OrderBlock Settings"
colors = input.string(title = "Color Scheme", defval="DARK", options=["DARK", "BRIGHT"], group=OB_GRP)
periods = input.int(3, "Relevant Periods to identify OB", group=OB_GRP)
threshold = input.float(0.0, "Min. Percent move to identify OB", step = 0.1, group=OB_GRP)
usewicks = input.bool(false, "Use whole range [High/Low] for OB marking?", group=OB_GRP)
showbull = input.bool(true, "Show latest Bullish Channel?", group=OB_GRP)
showbear = input.bool(true, "Show latest Bearish Channel?", group=OB_GRP)
showdocu = input.bool(false, "Show Label for documentation tooltip?", group=OB_GRP)
info_pan = input.bool(false, "Show Latest OB Panel?", group=OB_GRP)

ob_period = periods + 1
absmove = ((math.abs(close[ob_period] - close[1]))/close[ob_period]) * 100
relmove = absmove >= threshold

// Color Scheme
bullcolor = colors == "DARK"? color.white : color.green
bearcolor = colors == "DARK"? color.blue : color.red

// Bullish Order Block Identification
bullishOB = close[ob_period] < open[ob_period]

int upcandles = 0
for i = 1 to periods
    upcandles := upcandles + (close[i] > open[i]? 1 : 0)

OB_bull = bullishOB and (upcandles == (periods)) and relmove
OB_bull_high = OB_bull? usewicks? high[ob_period] : open[ob_period] : na
OB_bull_low = OB_bull? low[ob_period] : na
OB_bull_avg = (OB_bull_high + OB_bull_low)/2

// Bearish Order Block Identification
bearishOB = close[ob_period] > open[ob_period]

int downcandles = 0
for i = 1 to periods
    downcandles := downcandles + (close[i] < open[i]? 1 : 0)

OB_bear = bearishOB and (downcandles == (periods)) and relmove
OB_bear_high = OB_bear? high[ob_period] : na
OB_bear_low = OB_bear? usewicks? low[ob_period] : open[ob_period] : na
OB_bear_avg = (OB_bear_low + OB_bear_high)/2

// LuxAlgo-style OB implementation
// OB type
type OB
    float top
    float btm
    int   loc
    bool  is_bear

// OB arrays
var OB[] bullish_obs = array.new<OB>()
var OB[] bearish_obs = array.new<OB>()

// Detect and store OBs
if OB_bull
    array.unshift(bullish_obs, OB.new(OB_bull_high, OB_bull_low, bar_index - ob_period, false))
    if array.size(bullish_obs) > 10
        array.pop(bullish_obs)
if OB_bear
    array.unshift(bearish_obs, OB.new(OB_bear_high, OB_bear_low, bar_index - ob_period, true))
    if array.size(bearish_obs) > 10
        array.pop(bearish_obs)

// Delete all boxes and lines at the start of each bar
if barstate.isfirst or barstate.isnew
    for bx in box.all
        bx.delete()
    for ln in line.all
        ln.delete()

// Draw all OBs (LuxAlgo style)
if array.size(bullish_obs) > 0
    for i = 0 to array.size(bullish_obs)-1
        ob = array.get(bullish_obs, i)
        box.new(ob.loc, ob.top, bar_index, ob.btm, xloc=xloc.bar_index, bgcolor=color.new(color.blue, 80), border_color=color.new(color.blue, 0))
        label.new(ob.loc, ob.top, "BULLISH OB", color=color.new(color.blue, 0), textcolor=color.white, style=label.style_label_down, yloc=yloc.price, xloc=xloc.bar_index)
if array.size(bearish_obs) > 0
    for i = 0 to array.size(bearish_obs)-1
        ob = array.get(bearish_obs, i)
        box.new(ob.loc, ob.top, bar_index, ob.btm, xloc=xloc.bar_index, bgcolor=color.new(color.orange, 80), border_color=color.new(color.orange, 0))
        label.new(ob.loc, ob.top, "BEARISH OB", color=color.new(color.orange, 0), textcolor=color.white, style=label.style_label_up, yloc=yloc.price, xloc=xloc.bar_index)

// Alerts for Order Blocks Detection
alertcondition(OB_bull, title='New Bullish OB detected', message='New Bullish OB detected - This is NOT a BUY signal!')
alertcondition(OB_bear, title='New Bearish OB detected', message='New Bearish OB detected - This is NOT a SELL signal!')

// Print latest Order Blocks in Data Window
var latest_bull_high = 0.0
var latest_bull_avg = 0.0
var latest_bull_low = 0.0
var latest_bear_high = 0.0
var latest_bear_avg = 0.0
var latest_bear_low = 0.0

// Assign latest values to variables
if OB_bull_high > 0
    latest_bull_high := OB_bull_high

if OB_bull_avg > 0
    latest_bull_avg := OB_bull_avg

if OB_bull_low > 0
    latest_bull_low := OB_bull_low

if OB_bear_high > 0
    latest_bear_high := OB_bear_high
    
if OB_bear_avg > 0
    latest_bear_avg := OB_bear_avg
    
if OB_bear_low > 0
    latest_bear_low := OB_bear_low

// Plot invisible characters to be able to show the values in the Data Window
plotchar(latest_bull_high, char = ' ', location = location.abovebar, color = color.new(#777777, 100), size = size.tiny, title = "Latest Bull High")
plotchar(latest_bull_avg, char = ' ', location = location.abovebar, color = color.new(#777777, 100), size = size.tiny, title = "Latest Bull Avg")
plotchar(latest_bull_low, char = ' ', location = location.abovebar, color = color.new(#777777, 100), size = size.tiny, title = "Latest Bull Low")
plotchar(latest_bear_high, char = ' ', location = location.abovebar, color = color.new(#777777, 100), size = size.tiny, title = "Latest Bear High")
plotchar(latest_bear_avg, char = ' ', location = location.abovebar, color = color.new(#777777, 100), size = size.tiny, title = "Latest Bear Avg")
plotchar(latest_bear_low, char = ' ', location = location.abovebar, color = color.new(#777777, 100), size = size.tiny, title = "Latest Bear Low")

// InfoPanel for latest Order Blocks
draw_InfoPanel(_text, _x, _y, font_size)=>
    var label la_panel = na
    label.delete(la_panel)
    la_panel := label.new(
         x=_x, y=_y, 
         text=_text, xloc=xloc.bar_time, yloc=yloc.price, 
         color=color.new(#383838, 5), style=label.style_label_left, textcolor=color.white, size=font_size)

info_panel_x = time_close + math.round(ta.change(time) * 100)
info_panel_y = close

title = "LATEST ORDER BLOCKS"
row0 = "-----------------------------------------------------"
row1 = ' Bullish - High: ' + str.tostring(latest_bull_high, '#.##')
row2 = ' Bullish - Avg: ' + str.tostring(latest_bull_avg, '#.##')
row3 = ' Bullish - Low: ' + str.tostring(latest_bull_low, '#.##')
row4 = "-----------------------------------------------------"
row5 = ' Bearish - High: ' + str.tostring(latest_bear_high, '#.##')
row6 = ' Bearish - Avg: ' + str.tostring(latest_bear_avg, '#.##')
row7 = ' Bearish - Low: ' + str.tostring(latest_bear_low, '#.##')

panel_text = '\n' + title + '\n' + row0 + '\n' + row1 + '\n' + row2 + '\n' + row3 + '\n' + row4 + '\n\n' + row5 + '\n' + row6 + '\n' + row7 + '\n'

if info_pan
    draw_InfoPanel(panel_text, info_panel_x, info_panel_y, size.normal)

// === Label for Documentation/Tooltip ===
chper = time - time[1]
chper := ta.change(chper) > 0 ? chper[1] : chper

// === Tooltip text ===
var vartooltip = "Indicator to help identifying instituational Order Blocks. Often these blocks signal the beginning of a strong move, but there is a high probability, that these prices will be revisited at a later point in time again and therefore are interesting levels to place limit orders. \nBullish Order block is the last down candle before a sequence of up candles. \nBearish Order Block is the last up candle before a sequence of down candles. \nIn the settings the number of required sequential candles can be adjusted. \nFurthermore a %-threshold can be entered which the sequential move needs to achieve in order to validate a relevant Order Block. \nChannels for the last Bullish/Bearish Block can be shown/hidden."

// === Print Label ===
var label l_docu = na
label.delete(l_docu)

if showdocu
    l_docu := label.new(x = time + chper * 35, y = close, text = "DOCU OB", color=color.gray, textcolor=color.white, style=label.style_label_center, xloc = xloc.bar_time, yloc=yloc.price, size=size.tiny, textalign = text.align_left, tooltip = vartooltip)

// ==================
// M&W Pattern Settings
// ==================
MW_GRP = "M&W Pattern Settings"
x = input.int(21, "Time Horizon", tooltip = "Controls the look-back and time horizon of the patterns, a larger value will detect longer term patterns", group=MW_GRP)
sig = input.bool(false, "Show Signal Labels Only", tooltip = "When enabled, only the labels showing the second pivot of the double top/bottom will show", group=MW_GRP)

MW_COLORS = "M&W Pattern Colors"
green = input.color(#00ffbb, "Bullish Color", group = MW_COLORS, tooltip="Color for bullish trend")
red = input.color(#ff1100, "Bearish Color", group = MW_COLORS, tooltip="Color for bearish trend")

type store
    int   dir
    int   n
    float y

limit = ta.sma(math.abs(open-close), 100)

ph = ta.pivothigh(close, x,x)
pl = ta.pivotlow(close, x,x)

var pph = float(na)
var ppl = float(na)
var cpph = float(na)
var cppl = float(na)
var ln = int(na)
var hn = int(na)
var lpt = 0
var awaiting_DBC = 0
var awaiting_DTC = 0

potential = false
var store[] sequence = array.new<store>()
var t = array.new_line()
var t1 = array.new_line()
var tthresh = 0.0
var bthresh = 0.0

if not na(ph)
    lpt := 1
    if awaiting_DBC == 1
        awaiting_DBC := 0
        if not sig
            label.new(bar_index, bthresh, style = label.style_diamond, size = size.tiny, color = color.orange)
    if awaiting_DTC == 1
        awaiting_DTC := 0
        if not sig
            label.new(bar_index, tthresh, style = label.style_diamond, size = size.tiny, color = color.orange)
    if na(ppl)
        hn := bar_index-x
        cpph := ph
        sequence.unshift(store.new(1, hn, close[bar_index-hn]))
        pph := ph
        
    else if ph > ppl and (lpt == lpt[1] ? ph > pph : true)
        hn := bar_index-x
        cppl := ppl
        sequence.unshift(store.new(-1, ln, close[bar_index-ln]))
        pph := ph
        

if not na(pl)
    lpt := -1
    if awaiting_DBC == 1
        awaiting_DBC := 0
        if not sig
            label.new(bar_index, bthresh, style = label.style_diamond, size = size.tiny, color = color.orange)
    if awaiting_DTC == 1
        awaiting_DTC := 0
        if not sig
            label.new(bar_index, tthresh, style = label.style_diamond, size = size.tiny, color = color.orange)
    if na(pph)
        ln := bar_index-x
        cppl := pl
        sequence.unshift(store.new(-1, ln, close[bar_index-ln]))
        ppl := pl
        
    else if pl < pph and (lpt == lpt[1] ? pl < ppl : true)
        ln := bar_index-x
        cpph := pph
        sequence.unshift(store.new(1, hn, close[bar_index-hn]))
        ppl := pl

while sequence.size() > 3
    sequence.pop()

if sequence.size() > 2
    if not na(ph) and sequence.first().dir == -1 and sequence.get(1).dir == 1 and math.abs(close[x] - sequence.get(1).y) < limit and lpt[1] != 1
        trigger = sequence.get(0).y
        label.new(bar_index-x, close[x], style = label.style_label_down, size = size.large, color = red)
        if not sig
            t1.unshift(line.new(sequence.get(0).n, sequence.get(0).y, sequence.get(0).n + 1, sequence.get(0).y, xloc = xloc.bar_index, color = red, width = 2, style = line.style_dashed))
        awaiting_DTC := 1
        tthresh := sequence.get(0).y
        if not sig
            l0 = line.new(sequence.get(1).n, sequence.get(1).y, sequence.get(2).n, sequence.get(2).y, xloc = xloc.bar_index, color = red, width = 2)
            l1 = line.new(sequence.get(1).n, sequence.get(1).y, sequence.get(0).n, sequence.get(0).y, xloc = xloc.bar_index, color = red, width = 2)
            l2 = line.new(sequence.get(0).n, sequence.get(0).y, bar_index-x, ph, xloc = xloc.bar_index, color = red, width = 2)
            linefill.new(l0, l1, color.new(red, 70))
            linefill.new(t1.first(), l2, color.new(red, 70))

    if not na(pl) and sequence.first().dir == 1 and sequence.get(1).dir == -1 and math.abs(close[x] - sequence.get(1).y) < limit and lpt[1] != -1
        trigger = sequence.get(0).y
        label.new(bar_index-x, close[x], style = label.style_label_up, size = size.large, color = green)
        if not sig
            t.unshift(line.new(sequence.get(0).n, sequence.get(0).y, sequence.get(0).n + 1, sequence.get(0).y, xloc = xloc.bar_index, color = green, width = 2, style = line.style_dashed))
        awaiting_DBC := 1
        bthresh := sequence.get(0).y
        if not sig
            l0 = line.new(sequence.get(1).n, sequence.get(1).y, sequence.get(2).n, sequence.get(2).y, xloc = xloc.bar_index, color = green, width = 2)
            l1 = line.new(sequence.get(1).n, sequence.get(1).y, sequence.get(0).n, sequence.get(0).y, xloc = xloc.bar_index, color = green, width = 2)
            l2 = line.new(sequence.get(0).n, sequence.get(0).y, bar_index-x, pl, xloc = xloc.bar_index, color = green, width = 2)
            linefill.new(l0, l1, color.new(green, 70))
            linefill.new(t.first(), l2, color.new(green, 70))

DTC = 0
DBC = 0

if awaiting_DTC == 1
    if close < tthresh
        awaiting_DTC := 0
        tthresh := 0
        if not sig
            t1.first().set_x2(bar_index)
        DTC := 1

if awaiting_DBC == 1
    if close > bthresh
        awaiting_DBC := 0
        awaiting_DBC := 0
        if not sig
            t.first().set_x2(bar_index)
        DBC := 1

if t.size() > 0
    qt = t.size()

    for i = qt - 1 to 0
        if i < t.size()
            cL = t.get(i)
            yL = cL.get_x1()
            vert = cL.get_y1()

            if awaiting_DBC == 1
                cL.set_x2(bar_index + 1)

            else
                t.pop()

if t1.size() > 0
    qt = t.size()

    for i = qt - 1 to 0
        if i < t1.size()
            cL = t1.get(i)
            yL = cL.get_x1()
            vert = cL.get_y1()

            if awaiting_DTC == 1
                cL.set_x2(bar_index + 1)

            else
                t1.pop()

alertcondition(not na(pl) and sequence.first().dir == 1 and sequence.get(1).dir == -1 and math.abs(close[x] - sequence.get(1).y) < limit and lpt[1] != -1, "Potential Double Bottom")
alertcondition(not na(ph) and sequence.first().dir == -1 and sequence.get(1).dir == 1 and math.abs(close[x] - sequence.get(1).y) < limit and lpt[1] != 1, "Potential Double Top")
alertcondition(DBC == 1, "Double Bottom Confirmed")
alertcondition(DTC == 1, "Double Top Confirmed")
