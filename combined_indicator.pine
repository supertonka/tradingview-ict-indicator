//@version=5
indicator("OB & MW Pattern Visualizer", overlay=true, max_boxes_count=500, max_labels_count=500, max_lines_count=500)

// ==================
// Input Parameters
// ==================

// EMA Parameters
emaLength = input.int(20, "EMA Length", minval=1)
emaPipDistance = input.float(15.0, "OB Distance from EMA (pips)", minval=1.0)
emaColor = input.color(#2962FF, "EMA Color")

// OrderBlock Parameters
obLength = input.int(5, 'Volume Pivot Length', minval=1)
bullOBColor = input.color(color.new(#169400, 80), 'Bullish OB Color')
bearOBColor = input.color(color.new(#ff1100, 80), 'Bearish OB Color')

// M-W Pattern Parameters
mwLength = input.int(10, "M-W Pattern Length", minval=5)
mwBullColor = input.color(color.new(#169400, 80), "W Pattern Color")
mwBearColor = input.color(color.new(#ff1100, 80), "M Pattern Color")

// ==================
// Functions
// ==================

// OrderBlock Functions
get_coordinates(condition, top, btm, ob_val)=>
    var ob_top  = array.new_float(0)
    var ob_btm  = array.new_float(0)
    var ob_left = array.new_int(0)

    float ob = na

    if condition
        array.unshift(ob_top, top)
        array.unshift(ob_btm, btm)
        array.unshift(ob_left, time[obLength])
        ob := ob_val
    
    [ob_top, ob_btm, ob_left, ob]

remove_mitigated(ob_top, ob_btm, ob_left, target, bull)=>
    mitigated = false
    target_array = bull ? ob_btm : ob_top

    for element in target_array
        idx = array.indexof(target_array, element)
        if (bull ? target < element : target > element)
            mitigated := true
            array.remove(ob_top, idx)
            array.remove(ob_btm, idx)
            array.remove(ob_left, idx)
    
    mitigated

// M-W Pattern Functions
pivots(length)=>
    float ph = ta.highestbars(high, length) == 0 ? high : na
    float pl = ta.lowestbars(low, length) == 0 ? low : na
    dir = 0
    dir := ph and na(pl) ? 1 : pl and na(ph) ? -1 : dir[1]
    [dir, ph, pl]

var zigzagvalues = array.new_float(0)
var zigzagindexes = array.new_int(0)
var zigzagdir = array.new_int(0)

var doubleTopBottomValues = array.new_float(3)
var doubleTopBottomIndexes = array.new_int(3)
var doubleTopBottomDir = array.new_int(3)

int max_array_size = 10

add_to_array(value, index, dir)=>
    mult = array.size(zigzagvalues) < 2? 1 : 
                 (dir*value > dir*array.get(zigzagvalues,1))? 2 : 1
    array.unshift(zigzagindexes, index)
    array.unshift(zigzagvalues, value)
    array.unshift(zigzagdir, dir*mult)
    if array.size(zigzagindexes) > max_array_size
        array.pop(zigzagindexes)
        array.pop(zigzagvalues)
        array.pop(zigzagdir)

add_to_zigzag(dir, dirchanged, ph, pl, index)=>
    value = (dir == 1? ph : pl)
    if array.size(zigzagvalues) == 0 or dirchanged
        add_to_array(value, index, dir)
    else if(dir == 1 and value > array.get(zigzagvalues, 0)) or (dir == -1 and value < array.get(zigzagvalues, 0))
        array.shift(zigzagvalues)
        array.shift(zigzagindexes)
        array.shift(zigzagdir)
        add_to_array(value, index, dir)

zigzag(length)=>
    [dir, ph, pl] = pivots(length)
    dirchanged = ta.change(dir)
    if(ph or pl)
        add_to_zigzag(dir, dirchanged, ph, pl, bar_index)

calculate_double_pattern()=>
    doubleTop = false
    doubleBottom = false
    if(array.size(zigzagvalues) >= 4) 
        index = array.get(zigzagindexes, 1)
        value = array.get(zigzagvalues, 1)
        highLow = array.get(zigzagdir, 1)
        
        lindex = array.get(zigzagindexes, 2)
        lvalue = array.get(zigzagvalues, 2)
        lhighLow = array.get(zigzagdir, 2)
        
        llindex = array.get(zigzagindexes, 3)
        llvalue = array.get(zigzagvalues, 3)
        llhighLow = array.get(zigzagdir, 3)
        
        if(highLow == 1 and llhighLow == 2 and lhighLow < 0)
            doubleTop := true
        if(highLow == -1 and llhighLow == -2 and lhighLow > 0)
            doubleBottom := true

        if(doubleTop or doubleBottom)
            array.set(doubleTopBottomValues, 0, value)
            array.set(doubleTopBottomValues, 1, lvalue)
            array.set(doubleTopBottomValues, 2, llvalue)
            
            array.set(doubleTopBottomIndexes, 0, index)
            array.set(doubleTopBottomIndexes, 1, lindex)
            array.set(doubleTopBottomIndexes, 2, llindex)
            
            array.set(doubleTopBottomDir, 0, highLow)
            array.set(doubleTopBottomDir, 1, lhighLow)
            array.set(doubleTopBottomDir, 2, llhighLow)
    
    [doubleTop, doubleBottom]

// ==================
// Main Calculations
// ==================

// Calculate EMA
emaValue = ta.ema(close, emaLength)
plot(emaValue, "EMA", color=emaColor, linewidth=2)

// Calculate pip value for distance check
pipValue = syminfo.mintick * 10

// OrderBlock Detection
var os = 0
var target_bull = 0.
var target_bear = 0.

n = bar_index
upper = ta.highest(obLength)
lower = ta.lowest(obLength)

target_bull := ta.lowest(close, obLength)
target_bear := ta.highest(close, obLength)

os := high[obLength] > upper ? 0 : low[obLength] < lower ? 1 : os[1]

phv = ta.pivothigh(volume, obLength, obLength)

// Get bullish/bearish order blocks coordinates 
[bull_top, bull_btm, bull_left, bull_ob] = get_coordinates(phv and os == 1, hl2[obLength], low[obLength], low[obLength])
[bear_top, bear_btm, bear_left, bear_ob] = get_coordinates(phv and os == 0, high[obLength], hl2[obLength], high[obLength])

// Remove mitigated order blocks
mitigated_bull = remove_mitigated(bull_top, bull_btm, bull_left, target_bull, true)
mitigated_bear = remove_mitigated(bear_top, bear_btm, bear_left, target_bear, false)

// M-W Pattern Detection
zigzag(mwLength)
[doubleTop, doubleBottom] = calculate_double_pattern()

// ==================
// Visualization
// ==================

if barstate.islast
    // Draw OrderBlock rectangles (only if within 15 pips of EMA)
    if array.size(bull_top) > 0
        for i = 0 to array.size(bull_top)-1
            topPrice = array.get(bull_top, i)
            btmPrice = array.get(bull_btm, i)
            leftTime = array.get(bull_left, i)
            
            // Check if OB is within 15 pips of EMA
            if math.abs(math.avg(topPrice, btmPrice) - emaValue) <= emaPipDistance * pipValue
                box.new(leftTime, topPrice, time, btmPrice, 
                     bgcolor=bullOBColor, 
                     border_color=color.new(bullOBColor, 50))

    if array.size(bear_top) > 0
        for i = 0 to array.size(bear_top)-1
            topPrice = array.get(bear_top, i)
            btmPrice = array.get(bear_btm, i)
            leftTime = array.get(bear_left, i)
            
            // Check if OB is within 15 pips of EMA
            if math.abs(math.avg(topPrice, btmPrice) - emaValue) <= emaPipDistance * pipValue
                box.new(leftTime, topPrice, time, btmPrice, 
                     bgcolor=bearOBColor, 
                     border_color=color.new(bearOBColor, 50))

    // Draw M-W Pattern rectangles
    if doubleTop or doubleBottom
        value = array.get(doubleTopBottomValues, 0)  // Current pivot
        lvalue = array.get(doubleTopBottomValues, 1) // Neck level
        index = array.get(doubleTopBottomIndexes, 0)
        
        if doubleTop
            box.new(index, value, time, lvalue,
                 bgcolor=mwBearColor,
                 border_color=color.new(mwBearColor, 50))
        else
            box.new(index, value, time, lvalue,
                 bgcolor=mwBullColor,
                 border_color=color.new(mwBullColor, 50))

// ==================
// Alerts
// ==================
alertcondition(doubleBottom, "W Pattern Detected", "W pattern formed")
alertcondition(doubleTop, "M Pattern Detected", "M pattern formed")
alertcondition(bull_ob and math.abs(math.avg(array.get(bull_top, 0), array.get(bull_btm, 0)) - emaValue) <= emaPipDistance * pipValue, 
             "Bullish OB near EMA", "Bullish OrderBlock within 15 pips of EMA")
alertcondition(bear_ob and math.abs(math.avg(array.get(bear_top, 0), array.get(bear_btm, 0)) - emaValue) <= emaPipDistance * pipValue,
             "Bearish OB near EMA", "Bearish OrderBlock within 15 pips of EMA") 